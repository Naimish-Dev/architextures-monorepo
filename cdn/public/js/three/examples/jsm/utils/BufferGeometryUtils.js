import{BufferAttribute,BufferGeometry,Float32BufferAttribute,InstancedBufferAttribute,InterleavedBuffer,InterleavedBufferAttribute,TriangleFanDrawMode,TriangleStripDrawMode,TrianglesDrawMode,Vector3}from"../../../build/three.module.js";function computeTangents(){throw new Error("BufferGeometryUtils: computeTangents renamed to computeMikkTSpaceTangents.")}function computeMikkTSpaceTangents(geometry,MikkTSpace,negateSign=!0){if(!MikkTSpace||!MikkTSpace.isReady)throw new Error("BufferGeometryUtils: Initialized MikkTSpace library required.");if(!geometry.hasAttribute("position")||!geometry.hasAttribute("normal")||!geometry.hasAttribute("uv"))throw new Error('BufferGeometryUtils: Tangents require "position", "normal", and "uv" attributes.');function getAttributeArray(attribute){if(attribute.normalized||attribute.isInterleavedBufferAttribute){const dstArray=new Float32Array(attribute.getCount()*attribute.itemSize);for(let i=0,j=0;i<attribute.getCount();i++)dstArray[j++]=attribute.getX(i),dstArray[j++]=attribute.getY(i),attribute.itemSize>2&&(dstArray[j++]=attribute.getZ(i));return dstArray}return attribute.array instanceof Float32Array?attribute.array:new Float32Array(attribute.array)}const _geometry=geometry.index?geometry.toNonIndexed():geometry,tangents=MikkTSpace.generateTangents(getAttributeArray(_geometry.attributes.position),getAttributeArray(_geometry.attributes.normal),getAttributeArray(_geometry.attributes.uv));if(negateSign)for(let i=3;i<tangents.length;i+=4)tangents[i]*=-1;return _geometry.setAttribute("tangent",new BufferAttribute(tangents,4)),geometry!==_geometry&&geometry.copy(_geometry),geometry}function mergeBufferGeometries(geometries,useGroups=!1){const isIndexed=null!==geometries[0].index,attributesUsed=new Set(Object.keys(geometries[0].attributes)),morphAttributesUsed=new Set(Object.keys(geometries[0].morphAttributes)),attributes={},morphAttributes={},morphTargetsRelative=geometries[0].morphTargetsRelative,mergedGeometry=new BufferGeometry;let offset=0;for(let i=0;i<geometries.length;++i){const geometry=geometries[i];let attributesCount=0;if(isIndexed!==(null!==geometry.index))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+i+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),null;for(const name in geometry.attributes){if(!attributesUsed.has(name))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+i+'. All geometries must have compatible attributes; make sure "'+name+'" attribute exists among all geometries, or in none of them.'),null;void 0===attributes[name]&&(attributes[name]=[]),attributes[name].push(geometry.attributes[name]),attributesCount++}if(attributesCount!==attributesUsed.size)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+i+". Make sure all geometries have the same number of attributes."),null;if(morphTargetsRelative!==geometry.morphTargetsRelative)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+i+". .morphTargetsRelative must be consistent throughout all geometries."),null;for(const name in geometry.morphAttributes){if(!morphAttributesUsed.has(name))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+i+".  .morphAttributes must be consistent throughout all geometries."),null;void 0===morphAttributes[name]&&(morphAttributes[name]=[]),morphAttributes[name].push(geometry.morphAttributes[name])}if(useGroups){let count;if(isIndexed)count=geometry.index.count;else{if(void 0===geometry.attributes.position)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+i+". The geometry must have either an index or a position attribute"),null;count=geometry.attributes.position.count}mergedGeometry.addGroup(offset,count,i),offset+=count}}if(isIndexed){let indexOffset=0;const mergedIndex=[];for(let i=0;i<geometries.length;++i){const index=geometries[i].index;for(let j=0;j<index.count;++j)mergedIndex.push(index.getX(j)+indexOffset);indexOffset+=geometries[i].attributes.position.count}mergedGeometry.setIndex(mergedIndex)}for(const name in attributes){const mergedAttribute=mergeBufferAttributes(attributes[name]);if(!mergedAttribute)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+name+" attribute."),null;mergedGeometry.setAttribute(name,mergedAttribute)}for(const name in morphAttributes){const numMorphTargets=morphAttributes[name][0].length;if(0===numMorphTargets)break;mergedGeometry.morphAttributes=mergedGeometry.morphAttributes||{},mergedGeometry.morphAttributes[name]=[];for(let i=0;i<numMorphTargets;++i){const morphAttributesToMerge=[];for(let j=0;j<morphAttributes[name].length;++j)morphAttributesToMerge.push(morphAttributes[name][j][i]);const mergedMorphAttribute=mergeBufferAttributes(morphAttributesToMerge);if(!mergedMorphAttribute)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+name+" morphAttribute."),null;mergedGeometry.morphAttributes[name].push(mergedMorphAttribute)}}return mergedGeometry}function mergeBufferAttributes(attributes){let TypedArray,itemSize,normalized,arrayLength=0;for(let i=0;i<attributes.length;++i){const attribute=attributes[i];if(attribute.isInterleavedBufferAttribute)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported."),null;if(void 0===TypedArray&&(TypedArray=attribute.array.constructor),TypedArray!==attribute.array.constructor)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."),null;if(void 0===itemSize&&(itemSize=attribute.itemSize),itemSize!==attribute.itemSize)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."),null;if(void 0===normalized&&(normalized=attribute.normalized),normalized!==attribute.normalized)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."),null;arrayLength+=attribute.array.length}const array=new TypedArray(arrayLength);let offset=0;for(let i=0;i<attributes.length;++i)array.set(attributes[i].array,offset),offset+=attributes[i].array.length;return new BufferAttribute(array,itemSize,normalized)}export function deepCloneAttribute(attribute){return attribute.isInstancedInterleavedBufferAttribute||attribute.isInterleavedBufferAttribute?deinterleaveAttribute(attribute):attribute.isInstancedBufferAttribute?(new InstancedBufferAttribute).copy(attribute):(new BufferAttribute).copy(attribute)}function interleaveAttributes(attributes){let TypedArray,arrayLength=0,stride=0;for(let i=0,l=attributes.length;i<l;++i){const attribute=attributes[i];if(void 0===TypedArray&&(TypedArray=attribute.array.constructor),TypedArray!==attribute.array.constructor)return console.error("AttributeBuffers of different types cannot be interleaved"),null;arrayLength+=attribute.array.length,stride+=attribute.itemSize}const interleavedBuffer=new InterleavedBuffer(new TypedArray(arrayLength),stride);let offset=0;const res=[],getters=["getX","getY","getZ","getW"],setters=["setX","setY","setZ","setW"];for(let j=0,l=attributes.length;j<l;j++){const attribute=attributes[j],itemSize=attribute.itemSize,count=attribute.count,iba=new InterleavedBufferAttribute(interleavedBuffer,itemSize,offset,attribute.normalized);res.push(iba),offset+=itemSize;for(let c=0;c<count;c++)for(let k=0;k<itemSize;k++)iba[setters[k]](c,attribute[getters[k]](c))}return res}export function deinterleaveAttribute(attribute){const cons=attribute.data.array.constructor,count=attribute.count,itemSize=attribute.itemSize,normalized=attribute.normalized,array=new cons(count*itemSize);let newAttribute;newAttribute=attribute.isInstancedInterleavedBufferAttribute?new InstancedBufferAttribute(array,itemSize,normalized,attribute.meshPerAttribute):new BufferAttribute(array,itemSize,normalized);for(let i=0;i<count;i++)newAttribute.setX(i,attribute.getX(i)),itemSize>=2&&newAttribute.setY(i,attribute.getY(i)),itemSize>=3&&newAttribute.setZ(i,attribute.getZ(i)),itemSize>=4&&newAttribute.setW(i,attribute.getW(i));return newAttribute}export function deinterleaveGeometry(geometry){const attributes=geometry.attributes,morphTargets=geometry.morphTargets,attrMap=new Map;for(const key in attributes){const attr=attributes[key];attr.isInterleavedBufferAttribute&&(attrMap.has(attr)||attrMap.set(attr,deinterleaveAttribute(attr)),attributes[key]=attrMap.get(attr))}for(const key in morphTargets){const attr=morphTargets[key];attr.isInterleavedBufferAttribute&&(attrMap.has(attr)||attrMap.set(attr,deinterleaveAttribute(attr)),morphTargets[key]=attrMap.get(attr))}}function estimateBytesUsed(geometry){let mem=0;for(const name in geometry.attributes){const attr=geometry.getAttribute(name);mem+=attr.count*attr.itemSize*attr.array.BYTES_PER_ELEMENT}const indices=geometry.getIndex();return mem+=indices?indices.count*indices.itemSize*indices.array.BYTES_PER_ELEMENT:0,mem}function mergeVertices(geometry,tolerance=1e-4){tolerance=Math.max(tolerance,Number.EPSILON);const hashToIndex={},indices=geometry.getIndex(),positions=geometry.getAttribute("position"),vertexCount=indices?indices.count:positions.count;let nextIndex=0;const attributeNames=Object.keys(geometry.attributes),tmpAttributes={},tmpMorphAttributes={},newIndices=[],getters=["getX","getY","getZ","getW"],setters=["setX","setY","setZ","setW"];for(let i=0,l=attributeNames.length;i<l;i++){const name=attributeNames[i],attr=geometry.attributes[name];tmpAttributes[name]=new BufferAttribute(new attr.array.constructor(attr.count*attr.itemSize),attr.itemSize,attr.normalized);const morphAttr=geometry.morphAttributes[name];morphAttr&&(tmpMorphAttributes[name]=new BufferAttribute(new morphAttr.array.constructor(morphAttr.count*morphAttr.itemSize),morphAttr.itemSize,morphAttr.normalized))}const decimalShift=Math.log10(1/tolerance),shiftMultiplier=Math.pow(10,decimalShift);for(let i=0;i<vertexCount;i++){const index=indices?indices.getX(i):i;let hash="";for(let j=0,l=attributeNames.length;j<l;j++){const name=attributeNames[j],attribute=geometry.getAttribute(name),itemSize=attribute.itemSize;for(let k=0;k<itemSize;k++)hash+=`${~~(attribute[getters[k]](index)*shiftMultiplier)},`}if(hash in hashToIndex)newIndices.push(hashToIndex[hash]);else{for(let j=0,l=attributeNames.length;j<l;j++){const name=attributeNames[j],attribute=geometry.getAttribute(name),morphAttr=geometry.morphAttributes[name],itemSize=attribute.itemSize,newarray=tmpAttributes[name],newMorphArrays=tmpMorphAttributes[name];for(let k=0;k<itemSize;k++){const getterFunc=getters[k],setterFunc=setters[k];if(newarray[setterFunc](nextIndex,attribute[getterFunc](index)),morphAttr)for(let m=0,ml=morphAttr.length;m<ml;m++)newMorphArrays[m][setterFunc](nextIndex,morphAttr[m][getterFunc](index))}}hashToIndex[hash]=nextIndex,newIndices.push(nextIndex),nextIndex++}}const result=geometry.clone();for(const name in geometry.attributes){const tmpAttribute=tmpAttributes[name];if(result.setAttribute(name,new BufferAttribute(tmpAttribute.array.slice(0,nextIndex*tmpAttribute.itemSize),tmpAttribute.itemSize,tmpAttribute.normalized)),name in tmpMorphAttributes)for(let j=0;j<tmpMorphAttributes[name].length;j++){const tmpMorphAttribute=tmpMorphAttributes[name][j];result.morphAttributes[name][j]=new BufferAttribute(tmpMorphAttribute.array.slice(0,nextIndex*tmpMorphAttribute.itemSize),tmpMorphAttribute.itemSize,tmpMorphAttribute.normalized)}}return result.setIndex(newIndices),result}function toTrianglesDrawMode(geometry,drawMode){if(drawMode===TrianglesDrawMode)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),geometry;if(drawMode===TriangleFanDrawMode||drawMode===TriangleStripDrawMode){let index=geometry.getIndex();if(null===index){const indices=[],position=geometry.getAttribute("position");if(void 0===position)return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),geometry;for(let i=0;i<position.count;i++)indices.push(i);geometry.setIndex(indices),index=geometry.getIndex()}const numberOfTriangles=index.count-2,newIndices=[];if(drawMode===TriangleFanDrawMode)for(let i=1;i<=numberOfTriangles;i++)newIndices.push(index.getX(0)),newIndices.push(index.getX(i)),newIndices.push(index.getX(i+1));else for(let i=0;i<numberOfTriangles;i++)i%2==0?(newIndices.push(index.getX(i)),newIndices.push(index.getX(i+1)),newIndices.push(index.getX(i+2))):(newIndices.push(index.getX(i+2)),newIndices.push(index.getX(i+1)),newIndices.push(index.getX(i)));newIndices.length/3!==numberOfTriangles&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const newGeometry=geometry.clone();return newGeometry.setIndex(newIndices),newGeometry.clearGroups(),newGeometry}return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",drawMode),geometry}function computeMorphedAttributes(object){if(!0!==object.geometry.isBufferGeometry)return console.error("THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry."),null;const _vA=new Vector3,_vB=new Vector3,_vC=new Vector3,_tempA=new Vector3,_tempB=new Vector3,_tempC=new Vector3,_morphA=new Vector3,_morphB=new Vector3,_morphC=new Vector3;function _calculateMorphedAttributeData(object,attribute,morphAttribute,morphTargetsRelative,a,b,c,modifiedAttributeArray){_vA.fromBufferAttribute(attribute,a),_vB.fromBufferAttribute(attribute,b),_vC.fromBufferAttribute(attribute,c);const morphInfluences=object.morphTargetInfluences;if(morphAttribute&&morphInfluences){_morphA.set(0,0,0),_morphB.set(0,0,0),_morphC.set(0,0,0);for(let i=0,il=morphAttribute.length;i<il;i++){const influence=morphInfluences[i],morph=morphAttribute[i];0!==influence&&(_tempA.fromBufferAttribute(morph,a),_tempB.fromBufferAttribute(morph,b),_tempC.fromBufferAttribute(morph,c),morphTargetsRelative?(_morphA.addScaledVector(_tempA,influence),_morphB.addScaledVector(_tempB,influence),_morphC.addScaledVector(_tempC,influence)):(_morphA.addScaledVector(_tempA.sub(_vA),influence),_morphB.addScaledVector(_tempB.sub(_vB),influence),_morphC.addScaledVector(_tempC.sub(_vC),influence)))}_vA.add(_morphA),_vB.add(_morphB),_vC.add(_morphC)}object.isSkinnedMesh&&(object.boneTransform(a,_vA),object.boneTransform(b,_vB),object.boneTransform(c,_vC)),modifiedAttributeArray[3*a+0]=_vA.x,modifiedAttributeArray[3*a+1]=_vA.y,modifiedAttributeArray[3*a+2]=_vA.z,modifiedAttributeArray[3*b+0]=_vB.x,modifiedAttributeArray[3*b+1]=_vB.y,modifiedAttributeArray[3*b+2]=_vB.z,modifiedAttributeArray[3*c+0]=_vC.x,modifiedAttributeArray[3*c+1]=_vC.y,modifiedAttributeArray[3*c+2]=_vC.z}const geometry=object.geometry,material=object.material;let a,b,c;const index=geometry.index,positionAttribute=geometry.attributes.position,morphPosition=geometry.morphAttributes.position,morphTargetsRelative=geometry.morphTargetsRelative,normalAttribute=geometry.attributes.normal,morphNormal=geometry.morphAttributes.position,groups=geometry.groups,drawRange=geometry.drawRange;let i,j,il,jl,group,start,end;const modifiedPosition=new Float32Array(positionAttribute.count*positionAttribute.itemSize),modifiedNormal=new Float32Array(normalAttribute.count*normalAttribute.itemSize);if(null!==index)if(Array.isArray(material))for(i=0,il=groups.length;i<il;i++)for(group=groups[i],start=Math.max(group.start,drawRange.start),end=Math.min(group.start+group.count,drawRange.start+drawRange.count),j=start,jl=end;j<jl;j+=3)a=index.getX(j),b=index.getX(j+1),c=index.getX(j+2),_calculateMorphedAttributeData(object,positionAttribute,morphPosition,morphTargetsRelative,a,b,c,modifiedPosition),_calculateMorphedAttributeData(object,normalAttribute,morphNormal,morphTargetsRelative,a,b,c,modifiedNormal);else for(start=Math.max(0,drawRange.start),end=Math.min(index.count,drawRange.start+drawRange.count),i=start,il=end;i<il;i+=3)a=index.getX(i),b=index.getX(i+1),c=index.getX(i+2),_calculateMorphedAttributeData(object,positionAttribute,morphPosition,morphTargetsRelative,a,b,c,modifiedPosition),_calculateMorphedAttributeData(object,normalAttribute,morphNormal,morphTargetsRelative,a,b,c,modifiedNormal);else if(Array.isArray(material))for(i=0,il=groups.length;i<il;i++)for(group=groups[i],start=Math.max(group.start,drawRange.start),end=Math.min(group.start+group.count,drawRange.start+drawRange.count),j=start,jl=end;j<jl;j+=3)a=j,b=j+1,c=j+2,_calculateMorphedAttributeData(object,positionAttribute,morphPosition,morphTargetsRelative,a,b,c,modifiedPosition),_calculateMorphedAttributeData(object,normalAttribute,morphNormal,morphTargetsRelative,a,b,c,modifiedNormal);else for(start=Math.max(0,drawRange.start),end=Math.min(positionAttribute.count,drawRange.start+drawRange.count),i=start,il=end;i<il;i+=3)a=i,b=i+1,c=i+2,_calculateMorphedAttributeData(object,positionAttribute,morphPosition,morphTargetsRelative,a,b,c,modifiedPosition),_calculateMorphedAttributeData(object,normalAttribute,morphNormal,morphTargetsRelative,a,b,c,modifiedNormal);const morphedPositionAttribute=new Float32BufferAttribute(modifiedPosition,3),morphedNormalAttribute=new Float32BufferAttribute(modifiedNormal,3);return{positionAttribute:positionAttribute,normalAttribute:normalAttribute,morphedPositionAttribute:morphedPositionAttribute,morphedNormalAttribute:morphedNormalAttribute}}function mergeGroups(geometry){if(0===geometry.groups.length)return console.warn("THREE.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge."),geometry;let groups=geometry.groups;if(groups=groups.sort((a,b)=>a.materialIndex!==b.materialIndex?a.materialIndex-b.materialIndex:a.start-b.start),null===geometry.getIndex()){const positionAttribute=geometry.getAttribute("position"),indices=[];for(let i=0;i<positionAttribute.count;i+=3)indices.push(i,i+1,i+2);geometry.setIndex(indices)}const index=geometry.getIndex(),newIndices=[];for(let i=0;i<groups.length;i++){const group=groups[i],groupStart=group.start,groupLength=groupStart+group.count;for(let j=groupStart;j<groupLength;j++)newIndices.push(index.getX(j))}geometry.dispose(),geometry.setIndex(newIndices);let start=0;for(let i=0;i<groups.length;i++){const group=groups[i];group.start=start,start+=group.count}let currentGroup=groups[0];geometry.groups=[currentGroup];for(let i=1;i<groups.length;i++){const group=groups[i];currentGroup.materialIndex===group.materialIndex?currentGroup.count+=group.count:(currentGroup=group,geometry.groups.push(currentGroup))}return geometry}function toCreasedNormals(geometry,creaseAngle=Math.PI/3){const creaseDot=Math.cos(creaseAngle),hashMultiplier=100*(1+1e-10),verts=[new Vector3,new Vector3,new Vector3],tempVec1=new Vector3,tempVec2=new Vector3,tempNorm=new Vector3,tempNorm2=new Vector3;function hashVertex(v){const x=~~(v.x*(100*(1+1e-10))),y=~~(v.y*(100*(1+1e-10))),z=~~(v.z*(100*(1+1e-10)));return`${x},${y},${z}`}const resultGeometry=geometry.toNonIndexed(),posAttr=resultGeometry.attributes.position,vertexMap={};for(let i=0,l=posAttr.count/3;i<l;i++){const i3=3*i,a=verts[0].fromBufferAttribute(posAttr,i3+0),b=verts[1].fromBufferAttribute(posAttr,i3+1),c=verts[2].fromBufferAttribute(posAttr,i3+2);tempVec1.subVectors(c,b),tempVec2.subVectors(a,b);const normal=(new Vector3).crossVectors(tempVec1,tempVec2).normalize();for(let n=0;n<3;n++){const vert=verts[n],hash=hashVertex(vert);hash in vertexMap||(vertexMap[hash]=[]),vertexMap[hash].push(normal)}}const normalArray=new Float32Array(3*posAttr.count),normAttr=new BufferAttribute(normalArray,3,!1);for(let i=0,l=posAttr.count/3;i<l;i++){const i3=3*i,a=verts[0].fromBufferAttribute(posAttr,i3+0),b=verts[1].fromBufferAttribute(posAttr,i3+1),c=verts[2].fromBufferAttribute(posAttr,i3+2);tempVec1.subVectors(c,b),tempVec2.subVectors(a,b),tempNorm.crossVectors(tempVec1,tempVec2).normalize();for(let n=0;n<3;n++){const vert=verts[n],hash=hashVertex(vert),otherNormals=vertexMap[hash];tempNorm2.set(0,0,0);for(let k=0,lk=otherNormals.length;k<lk;k++){const otherNorm=otherNormals[k];tempNorm.dot(otherNorm)>creaseDot&&tempNorm2.add(otherNorm)}tempNorm2.normalize(),normAttr.setXYZ(i3+n,tempNorm2.x,tempNorm2.y,tempNorm2.z)}}return resultGeometry.setAttribute("normal",normAttr),resultGeometry}export{computeTangents,computeMikkTSpaceTangents,mergeBufferGeometries,mergeBufferAttributes,interleaveAttributes,estimateBytesUsed,mergeVertices,toTrianglesDrawMode,computeMorphedAttributes,mergeGroups,toCreasedNormals};